-- 1. Запрос на выборку данных с использованием рефлексивного соединения для таблицы Издание:
SELECT
i1.Заглавие,
i2.Заглавие
FROM Издание i1
JOIN Издание i2 ON i1.Код_читателя = i2.Код_читателя
WHERE i1.Код_издания != i2.Код_издания
-- Этот запрос выберет все заглавия книг, которые находятся на руках у одного и того же читателя (рефлексивное соединение).


-- 2. Запрос на выборку данных с использованием простого оператора CASE:
SELECT Заглавие,
CASE
WHEN Год_издания > 2000 THEN 'Современная книга'
ELSE 'Классическая книга'
END AS 'Тип книги'
FROM Издание
-- Этот запрос выберет заглавие и тип книги (современная или классическая) в зависимости от года издания (простой оператор CASE).


-- 3. Запрос на выборку данных с использованием поискового оператора CASE:
SELECT
Заглавие,
CASE
WHEN Заглавие LIKE '%война%' THEN 'Книга о войне'
WHEN Заглавие LIKE '%мир%' THEN 'Книга о мире'
ELSE 'Другая книга'
END AS 'Тип книги'
FROM Издание
-- Этот запрос выберет заглавие и тип книги (книга о войне, книга о мире или другая книга) в зависимости от содержания заглавия
-- (поисковый оператор CASE).


-- 4. Запрос на выборку данных с использованием оператора WITH:
WITH
Новые_книги AS (
SELECT
Заглавие,
Год_издания
FROM Издание
WHERE Год_издания > 2020
)
SELECT *
FROM Новые_книги
-- Этот запрос выберет заглавие и год издания всех книг, выпущенных после 2020 года, используя оператор WITH.


-- 5. Запрос на выборку данных с использованием встроенного представления:
CREATE VIEW Чтения_читателя AS
SELECT Издание.Код_издания, Читатель.Код_читателя, Читатель.ФИО, Издание.Заглавие,
  Издание.Дата_поступления, Издание.Дата_списания
FROM Издание
LEFT JOIN Читатель ON Издание.Код_читателя = Читатель.Код_читателя;
-- Этот запрос создаст встроенное представление Новые_книги, выберет заглавие и год издания всех книг, выпущенных после 2020
-- года, и выведет результат.


-- 6. Запрос на выборку данных с использованием некоррелированного запроса:
SELECT Издательство.Название, COUNT(*) AS Количество_изданий
FROM Издание
JOIN Издательство ON Издание.Код_издательства = Издательство.Код_издательства
GROUP BY Издательство.Название
HAVING COUNT(*) > 5;
-- Этот запрос выбирает названия издательств и количество изданий, которые они выпустили, и ограничивает результаты только теми
-- издательствами, которые выпустили более пяти книг.


-- 7. Пример использования коррелированного запроса:
SELECT Читатель.ФИО, COUNT(*) AS Количество_книг
FROM Издание
JOIN Читатель ON Издание.Код_читателя = Читатель.Код_читателя
WHERE Год_издания > (
  SELECT AVG(Год_издания)
  FROM Издание
)
GROUP BY Читатель.ФИО;
-- Этот запрос выбирает имена читателей и количество книг, которые они взяли в библиотеке, и ограничивает результаты только теми,
-- кто взял книги, выпущенные после среднего года издания всех книг в библиотеке.


-- 8. Пример использования функции NULLIF:
SELECT Код_читателя, NULLIF(ФИО, '') AS ФИО_чтения
FROM Читатель;
-- Этот запрос выбирает коды читателей и их имена, но заменяет пустые имена на NULL с помощью функции NULLIF.


-- 9. Пример использования TOP-N анализа:
SELECT TOP 5 Заглавие, Год_издания, Количество_страниц
FROM Издание
ORDER BY Год_издания DESC;
-- Этот запрос позволяет выбрать первые пять изданий по убыванию года издания.


-- 10. Функция ROLLUP:
SELECT Код_издательства, Код_типа_издания, COUNT(*) AS Количество
FROM Издание
GROUP BY Код_издательства, Код_типа_издания WITH ROLLUP;
-- Этот запрос позволяет посчитать количество изданий по каждому издательству и типу издания с использованием функции ROLLUP, 
-- которая добавляет дополнительные строки для общих итогов.


-- 11. Оператор MERGE:
MERGE INTO Издание AS Target
USING (SELECT Код_читателя, Дата_списания FROM Издание WHERE На_руках = 'да') AS Source
ON Target.Код_читателя = Source.Код_читателя
WHEN MATCHED THEN UPDATE SET На_руках = 'нет', Дата_списания = Source.Дата_списания;
-- Этот запрос использует оператор MERGE для обновления статуса на руках у изданий, которые были взяты на руки читателями.